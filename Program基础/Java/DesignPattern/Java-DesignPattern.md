## 设计模式分析
参考：
[《2W 字详解设计模式》](https://mp.weixin.qq.com/s/n33Fv08-CWd4yi69u2M_3g)

- 装饰者模式(Decorator/Wrapper)：在不改变原来类的基础上，通过装饰者类来丰富和扩展原来类的功能（即装饰作用）。
换句话说，在另一个类中对旧方法进行了封装整合（即装饰）。
如果没有装饰者模式，而为每一种装饰组合设计一种类，那么就会造成“类爆炸”

- 建造者（Builder）模式：用于分步构造一个复杂对象，简化和隐藏了构造过程。
避免创建复杂和冗余的构造函数，区分了“必须设置”和“默认设置”的属性。

- 观察者（observer）模式：被观察者对象维持了一个list。这个list中包含了众多观察者。
当满足某些条件时，被观察者通过遍历list中的对象，逐一通知观察者。
其中，JDK为开发者提供了观察者模式的实现。
	- 观察者：implements Observer；被观察者：extends Observable
	- 注册：myObservable.addObserver(myObserver);
	在被观察者内部，调用两个方法，通知观察者发生改变。
				setChanged();
        notifyObservers(arg);
	首先，使用Vector，Vector相比于ArrayList来说，它是线程安全的。
	其次，在添加和删除观察者时对两个方法使用了synchronized关键字，这都是在为多线程考虑。



- 外观模式(facade)



- 责任链模式


- 单例模式
**单例的生命周期**
按照单例的定义，无法构建除该单例以外的实例，并且这个**单例有一个静态引用**，单例不会被虚拟机垃圾回收。单例对象一旦创建，对象的引用是保存在静态区，**单例对象在堆上分配的内存空间只有在程序终止后才会释放**，过多的单例必然增大内存的消耗，并且如果**单例中的上下文引用了不当，可能会造成严重的内存泄露问题**。
单例的设计应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该用单例来管理。

- 状态模式




- 策略模式

