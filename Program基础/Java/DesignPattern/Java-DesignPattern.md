# 设计模式分析
参考：
[《2W 字详解设计模式》](https://mp.weixin.qq.com/s/n33Fv08-CWd4yi69u2M_3g)

## 1、创建型

### 1.1 建造者（Builder）模式
用于分步构造一个复杂对象，简化和隐藏了构造过程。
避免创建复杂和冗余的构造函数，区分了“必须设置”和“默认设置”的属性。

### 1.2 工厂模式
- 简单工厂（不是一种设计模式）
1. 对产品进行抽象```IProduct```
2. 一个固定的工厂```SimpleFactory```，一个```IProduct Create(type)```方法
3. 根据参数```type```，简单工厂创建具体的产品

- 工厂模式
1. 对产品进行抽象```IProduct```
2. 对工厂进行抽象```Factory```，一个```IProduct Create(type)```方法
3. **继承**父类工厂，分别创建多个子类工厂：```AFactory```，```BFactory```等，实现具体的函数。
4. 各个子类工厂，通过```type```，创建一类具体的产品。

- 抽象工厂
1. 对产品进行抽象```IProduct```
2. 对工厂进行抽象```IFactory```，多个```IAProduct CreateA(type)```，```IBProduct CreateB(type)```方法
3. 实现父类工厂接口，分别创建多个子类工厂：```AFactory```，```BFactory```等，实现具体的函数
4. 各个子类工厂，通过```type```，通过多个方法**进行组合**创建**多种**产品。

- 工厂模式和抽象工厂的区别：
1. 工厂模式使用的是继承，抽象工厂使用的是组合
2. 工厂模式可以创建一类产品，抽象工厂可以创建多类产品，即一个产品族

### 1.3 单例模式
#### 1.3.1 分类
- 恶汉式：这个类第一次使用的时候就创建了一个实例
- 饱汉式：这个类真正被使用的时候（调用getInstance）的时候，才创建一个实例

#### 1.3.2 单例的生命周期
按照单例的定义，该类只能构建一个实例，并且这个**单例有一个静态引用**。**单例对象在堆上分配的内存空间只有在程序终止后才会释放**，所以在程序正常运行时，单例对象不会被虚拟机垃圾回收。
过多的单例必然增大内存的消耗，并且如果**单例中的上下文引用了不当，可能会造成严重的内存泄露问题**。
单例的设计应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该用单例来管理。

### 1.4 原型模式
原型模式很简单：有一个原型实例，基于这个原型实例产生新的实例，也就是“克隆”了。
java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。

## 2、结构型



## 3、行为型





- 装饰者模式(Decorator/Wrapper)：在不改变原来类的基础上，通过装饰者类来丰富和扩展原来类的功能（即装饰作用）。
换句话说，在另一个类中对旧方法进行了封装整合（即装饰）。
如果没有装饰者模式，而为每一种装饰组合设计一种类，那么就会造成“类爆炸”



- 观察者（observer）模式：被观察者对象维持了一个list。这个list中包含了众多观察者。
当满足某些条件时，被观察者通过遍历list中的对象，逐一通知观察者。
其中，JDK为开发者提供了观察者模式的实现。
	- 观察者：implements Observer；被观察者：extends Observable
	- 注册：myObservable.addObserver(myObserver);
	在被观察者内部，调用两个方法，通知观察者发生改变。
				setChanged();
        notifyObservers(arg);
	首先，使用Vector，Vector相比于ArrayList来说，它是线程安全的。
	其次，在添加和删除观察者时对两个方法使用了synchronized关键字，这都是在为多线程考虑。



- 外观模式(facade)



- 责任链模式


- 单例模式


- 状态模式




- 策略模式

