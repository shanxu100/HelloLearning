# 锁的简介

## 1、基本
参考：  
[《锁介绍名词解释》](https://blog.csdn.net/qq_31564573/article/details/107738571)  
[《并发扣款一致性优化，CAS下ABA问题，这个话题还没聊完！！！》](https://juejin.cn/post/6920098675700006925)  
[《面试必备-线程中的锁》](https://juejin.cn/post/6987019348309360654)
[《面试突击44：volatile 有什么用?》](https://juejin.cn/post/7094087043013640228)


## 2、锁的分类

### 2.1 常见名词：

- 可重入锁：在执行对象中所有同步方法不用再次获得锁。
- 可中断锁：在等待获取锁过程中可中断
- 公平锁：按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利
- 读写锁：读的时候可以多线程一起读，写的时候必须同步地写
- 自旋锁：
- 共享锁和独占锁
- ....

这些锁只是在不同角度对锁的特征进行了归类


### 2.2 乐观锁与悲观锁
- 乐观锁
（多个线程读取到同一个变量，然后在自己的线程中做修改。）只有在更新数据的时候才去判断之前有没有别的线程更新了这个数据。
**CAS（Compare And Swap，比较替换）算法**：当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，当前内存值V，旧的预期值A，新值B。**当且仅当预期值A和当前内存值V相同时，将当前内存值V修改为B，否则什么都不做**。
它有3个核心参数：
```
V：要修改的变量
A ：V的原有值，即线程读取V时的值
B：要修改成的值

解释：在对V做修改之前，先检查V的值是否与预期值A相等，如果相等就把V值更新为B，否则不更新，CAS失败。
```
- 悲观锁
自己在使用数据的时候，其他线程无法访问，只能等待。
Java中，```synchronized```关键字和```Lock```的实现类都是悲观锁

### 2.3 公平锁与非公平锁

- 非公平锁  
就是一种获取锁的抢占机制，即所有等待的任务**随机获得锁**，或者说**获取锁的顺序与申请锁的顺序无关**。  
**实现：**  
```Lock lock = new ReentrantLock();```  
```Lock lock = new ReentrantLock(false);```  
```synchronized关键字```   
**优点：** 效率高（如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁）   
**缺点：** 可能产生饥饿问题   

- 公平锁  
表示线程获取锁的顺序是**按照线程加锁的顺序来分配的**，即先加锁先执行、先来先得、先进先出FIFO的顺序。   
**背景：** 当多个任务等待获取锁时，CPU是按照“在等待队列里随机挑选一个线程”的调度规则执行的。那么就可能造成某一个任务永远得不到执行的问题，即造成饥饿问题。   
**优点：** 公平锁可以**避免饥饿问题的产生**。   
**缺点：** 与非公平锁相比，公平锁的效率会比较低。因为需要维持一个有序的序列。  
**实现：** ```Lock lock = new ReentrantLock(true);```  


### 2.4 可重入锁与非可重入锁
- 可重入锁：  
可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，该线程再进入的内层方法会自动获取锁（**前提锁对象得是同一个对象或者class**），不会因为之前已经获取过还没释放而阻塞。
**举例：** 当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。
Java中```ReentrantLock```和```synchronized```都是可重入锁。
**优点：** 可一定程度避免死锁。
- 非可重入锁：   
非可重入锁```NonReentrantLock```容易引起死锁。

### 2.5 共享锁和独占锁
- 共享锁：共享锁指一把锁可以被多个线程共享，最常见的共享锁就是**读写锁中的读锁**。
- 独占锁：独占锁指的是一把锁只有一个线程能够占用，其他锁大都是独占锁。

### 2.6 自旋锁和非自旋锁
- 自旋锁：自旋锁指的是如果一个线程拿不到锁，那么会循环尝试，这样可以避免陷入阻塞态
  补充：
  1. 如果很长时间都拿不到，那么就白自旋，浪费cpu；
  2. 所以jdk1.6升级了自旋锁为自适应自旋，每次自旋都会延长时间，从而避免浪费cpu

- 非自旋锁：非自旋锁获取不到就直接陷入阻塞态

### 2.7 可中断锁和不可中断锁
- 可中断锁：指的是响应中断的，比如可重入锁```ReentrantLock```
- 不可重入锁：指的是不响应中断的，比如```synchronized```。

## 3 ```synchronized```、```volatile```和 ```Lock```

### 3.1 ```volatile```具备两层语义：
- **保证可见性**：即保证了不同线程对这个共享变量进行操作时的可见性。工作内存中发生变化之后，必须马上回写到主内存，而线程读取```volatile```变量的时候，必须马上到主内存中去取最新值而不是读取本地工作内存的副本。```volatile```并不能保证在多线程下是安全的，因为Java中的运算并非原子操作。
  举例：定义volatile int count = 0，2个线程同时执行count++操作，每个线程都执行500次，最终结果小于1000，原因是每个线程执行count++需要以下3个步骤：
  1. 步骤1 线程从主内存读取最新的count的值
  2. 步骤2 执行引擎把count值加1，并赋值给线程工作内存
  3. 步骤3 线程工作内存把count值保存到主内存有可能某一时刻2个线程在步骤1读取到的值都是100，执行完步骤2得到的值都是101，最后刷新了2次101保存到主内存。

- **禁止进行指令重排序**：为了获取更好的性能，编译器或运行时环境（处理器）可能会对指令重新排序。
以单例模式为例：
```java
public class Singleton {
    private Singleton() {}
    private static Singleton instance = null;   //此处不添加 volatile
    public static Singleton getInstance() {
        if (instance == null) {                 // 位置1
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // 位置2
                }
            }
        }
        return instance;
    }
}
```
在`位置2`处创建对象的过程，其实际执行却分为以下 3 步：
1. 创建内存空间
2. 在内存空间中初始化对象 `Singleton`
3. 将内存地址赋值给`instance`对象（执行了此步骤，`instance` 就不等于 `null` 了）

如果此变量不加 `volatile`，那么 线程1 在执行到上述代码的`第2处`时就可能会执行指令重排序：将原本是 1、2、3 的执行顺序，重排为 1、3、2。
但是特殊情况下，线程1 在执行完第 3 步之后，如果来了 线程2 执行到上述代码的`第1处`，判断 `instance` 对象已经不为 `null`。
但此时 线程1 还未将对象实例化完，那么 线程2 将会得到一个**被实例化“一半”的对象**，从而导致程序执行出错。
这就是为什么要给私有变量添加 `volatile` 的原因了。

### 3.2 ```synchronized```和```volatile```的区别

- ```volatile```本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取
- ```synchronized```则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
- ```volatile```仅能使用在变量级别，```synchronized```则可以使用在变量、方法、和类级别的

注：
1. ```volatile```不能保证线程安全，**因为```volatile```不保证原子性**。比如操作：从内存中读取值 --> 加1 --> 写回内存。在两个线程中进行此操作，结果不一定“加2”。
2. 在需要同步的时候，**第一选择应该是```synchronized```关键字**，这是最安全的方式，尝试其他任何方式都是有风险的。
    尤其在、jdK1.5之后，对```synchronized```同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。
3. 用```synchronized```来加锁的方法抛异常的时候，锁仍然可以由JVM来自动释放。


### 3.3 ```synchronized```与```Lock```的区别
- synchronized是Java关键字，由JVM实现同步，释放由JVM来完成，不用人工干预；
- Lock是一个接口interface，ReentrentLock实现了该接口。

Lock的优点：Lock对锁的操作更加灵活：  
- synchronized不可中断，Lock可中断：使用 synchronized 关键字获取锁的时候，如果线程没有获取到被阻塞了，那么这个时候该线程是不响应中断 (interrupt) 的，而使用 ```Lock.lockInterruptibly(```) 获取锁时被中断，线程将抛出中断异常。
- Lock可非阻塞获取锁 ：使用 ```synchronized``` 关键字获取锁时，如果没有成功获取，只有被阻塞，而使用 ```lock.tryLock()``` 获取锁时，如果没有获取成功也不会阻塞而是直接返回 ```false```。

synchronized的优点：
- 与```Lock```相比，```synchronized```使用起来更加简单
- ```synchronized```同步由JVM层实现，效率更加高（引入很多优化措施如偏向锁、轻量锁等）

- ```synchronized```是非公平锁，```Lock```有公平锁和非公平锁


## 4、FAQ

### 4.1 CAS算法中的ABA问题
- 什么是ABA？  
对于一个变量，执行以下操作：
  1. 线程1（上）：获取出数据的初始值是 A，在本线程中修改为C
  2. 线程 2：将数据修改成 B
  3. 线程 3：将数据修改回 A
  4. 线程1（下）：写回数据时，检测发现初始值还是 A，满足CAS条件，更新该变量为C

从上面的过程中可以看到，线程A并不知道该变量是否被修改过。
所以，引起ABA问题的原因简单来说就是**CAS 过程中只简单进行了 “值” 的校验**。其实很多场景如果只追求最后结果正确，这是没关系的。但是实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯。


- 那怎么解决ABA问题？  
用**版本号**去保证就好了，就比如说，在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号加1。
除了版本号，使用**时间戳**也是可以的：查询的时候把时间戳一起查出来，更新时，同时比较旧值和时间戳，只有对的上的情况下才修改。并且更新值的时候一起更新时间戳。

### 4.2 ```volatile```适用于什么场景？有什么好处？
使用场景：就是“一个写入，多个读取”，即某一线程负责更新变量，其他线程只读取变量(不更新变量)，并根据变量的新值执行相应逻辑。例如状态标志位更新，观察者模型变量值发布。



