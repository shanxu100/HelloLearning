
----------
## 死锁
### 死锁的必要条件
互斥 至少有一个资源处于非共享状态
占有并等待
非抢占
循环等待
### 解决死锁，
第一个是死锁预防，就是不让上面的四个条件同时成立。二是，合理分配资源。
三是避免死锁：使用银行家算法
即，如果该进程请求的资源，操作系统不能满足，则等待；如果满足，会尝试进行分配。之后进行安全检查：如果安全，则请求资源成功；否则撤销分配。
安全检查：判断执行队列中的其它进程，若所有进程都可执行完毕，则系统处于安全状态。

安全状态一定是没有死锁发生，不安全状态不一定导致死锁。

Available[ ]矩阵数组表示某类资源的可用量

Claim[ i ][ j ]表示进程Pi最大需要Rj类资源的数量

Allocation[ i ][ j ]表示Pi已占有的Rj类资源数量

Need[ i ][ j ]表示Pi尚需Rj类资源的数量

——————————————————————-

Need[ i ][ j ]=Claim[ i ][ j ]—Allocation[ i ][ j ]

——————————————————————-

Request[ i ]表示进程Pi进程的申请向量，如 Request[ i ][ j ]=m 表示Pi申请m个Rj类资源

对于当前进程Pi X

(1) 检查if( Request[ i ][ j ]<=Need[ i ][ j ] ) goto (2)

else error(“进程 i 对资源的申请量大于其说明的最大值 ”);

(2) 检查 if ( Request[ i ][ j ]<=Available[ j ] ) goto (3)

else wait() ; /*注意是等待！即在对后续进程的需求资源判断中，若出现不符合的则安全检查结束，当前进程进入等待*/

(3) 系统试探地把资源分给Pi 并修改各项属性值 （具体是否成立，则根据安全检查的结果）

Available[ j ]  =Available[ j ] — Request[ i ][ j ]

Allocation[ i ][ j ]=Allocation[ i ][ j ] +Request[ i ][ j ]

Need[ i ][ j ]=Need[ i ][ j ]— Request[ i ][ j ]

(4) 安全检查，若检查结果为安全，则（3）中执行有效，否则分配作废，使该Pi进程进入等待
